// // coverage:ignore-file
// // GENERATED CODE - DO NOT MODIFY BY HAND
// // ignore_for_file: type=lint
// // ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

// part of 'asset.dart';

// // **************************************************************************
// // FreezedGenerator
// // **************************************************************************

// T _$identity<T>(T value) => value;

// final _privateConstructorUsedError = UnsupportedError(
//     'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

// Asset _$AssetFromJson(Map<String, dynamic> json) {
//   return _Asset.fromJson(json);
// }

// /// @nodoc
// mixin _$Asset {
//   int get id =>
//       throw _privateConstructorUsedError; //  required Account accountID,
// //  required Addresss addressID,
//   String? get tokenId => throw _privateConstructorUsedError;
//   String? get nftContract => throw _privateConstructorUsedError;
//   int? get nitialSupply => throw _privateConstructorUsedError;
//   String? get image => throw _privateConstructorUsedError;
//   String? get tokenURI => throw _privateConstructorUsedError;
//   String? get name => throw _privateConstructorUsedError;
//   String? get typeoff => throw _privateConstructorUsedError;
//   String? get uri => throw _privateConstructorUsedError;
//   double? get createdAt => throw _privateConstructorUsedError;
//   double? get updatedAt => throw _privateConstructorUsedError;

//   Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
//   @JsonKey(ignore: true)
//   $AssetCopyWith<Asset> get copyWith => throw _privateConstructorUsedError;
// }

// /// @nodoc
// abstract class $AssetCopyWith<$Res> {
//   factory $AssetCopyWith(Asset value, $Res Function(Asset) then) =
//       _$AssetCopyWithImpl<$Res, Asset>;
//   @useResult
//   $Res call(
//       {int id,
//       String? tokenId,
//       String? nftContract,
//       int? nitialSupply,
//       String? image,
//       String? tokenURI,
//       String? name,
//       String? typeoff,
//       String? uri,
//       double? createdAt,
//       double? updatedAt});
// }

// /// @nodoc
// class _$AssetCopyWithImpl<$Res, $Val extends Asset>
//     implements $AssetCopyWith<$Res> {
//   _$AssetCopyWithImpl(this._value, this._then);

//   // ignore: unused_field
//   final $Val _value;
//   // ignore: unused_field
//   final $Res Function($Val) _then;

//   @pragma('vm:prefer-inline')
//   @override
//   $Res call({
//     Object? id = null,
//     Object? tokenId = freezed,
//     Object? nftContract = freezed,
//     Object? nitialSupply = freezed,
//     Object? image = freezed,
//     Object? tokenURI = freezed,
//     Object? name = freezed,
//     Object? typeoff = freezed,
//     Object? uri = freezed,
//     Object? createdAt = freezed,
//     Object? updatedAt = freezed,
//   }) {
//     return _then(_value.copyWith(
//       id: null == id
//           ? _value.id
//           : id // ignore: cast_nullable_to_non_nullable
//               as int,
//       tokenId: freezed == tokenId
//           ? _value.tokenId
//           : tokenId // ignore: cast_nullable_to_non_nullable
//               as String?,
//       nftContract: freezed == nftContract
//           ? _value.nftContract
//           : nftContract // ignore: cast_nullable_to_non_nullable
//               as String?,
//       nitialSupply: freezed == nitialSupply
//           ? _value.nitialSupply
//           : nitialSupply // ignore: cast_nullable_to_non_nullable
//               as int?,
//       image: freezed == image
//           ? _value.image
//           : image // ignore: cast_nullable_to_non_nullable
//               as String?,
//       tokenURI: freezed == tokenURI
//           ? _value.tokenURI
//           : tokenURI // ignore: cast_nullable_to_non_nullable
//               as String?,
//       name: freezed == name
//           ? _value.name
//           : name // ignore: cast_nullable_to_non_nullable
//               as String?,
//       typeoff: freezed == typeoff
//           ? _value.typeoff
//           : typeoff // ignore: cast_nullable_to_non_nullable
//               as String?,
//       uri: freezed == uri
//           ? _value.uri
//           : uri // ignore: cast_nullable_to_non_nullable
//               as String?,
//       createdAt: freezed == createdAt
//           ? _value.createdAt
//           : createdAt // ignore: cast_nullable_to_non_nullable
//               as double?,
//       updatedAt: freezed == updatedAt
//           ? _value.updatedAt
//           : updatedAt // ignore: cast_nullable_to_non_nullable
//               as double?,
//     ) as $Val);
//   }
// }

// /// @nodoc
// abstract class _$$_AssetCopyWith<$Res> implements $AssetCopyWith<$Res> {
//   factory _$$_AssetCopyWith(_$_Asset value, $Res Function(_$_Asset) then) =
//       __$$_AssetCopyWithImpl<$Res>;
//   @override
//   @useResult
//   $Res call(
//       {int id,
//       String? tokenId,
//       String? nftContract,
//       int? nitialSupply,
//       String? image,
//       String? tokenURI,
//       String? name,
//       String? typeoff,
//       String? uri,
//       double? createdAt,
//       double? updatedAt});
// }

// /// @nodoc
// class __$$_AssetCopyWithImpl<$Res> extends _$AssetCopyWithImpl<$Res, _$_Asset>
//     implements _$$_AssetCopyWith<$Res> {
//   __$$_AssetCopyWithImpl(_$_Asset _value, $Res Function(_$_Asset) _then)
//       : super(_value, _then);

//   @pragma('vm:prefer-inline')
//   @override
//   $Res call({
//     Object? id = null,
//     Object? tokenId = freezed,
//     Object? nftContract = freezed,
//     Object? nitialSupply = freezed,
//     Object? image = freezed,
//     Object? tokenURI = freezed,
//     Object? name = freezed,
//     Object? typeoff = freezed,
//     Object? uri = freezed,
//     Object? createdAt = freezed,
//     Object? updatedAt = freezed,
//   }) {
//     return _then(_$_Asset(
//       id: null == id
//           ? _value.id
//           : id // ignore: cast_nullable_to_non_nullable
//               as int,
//       tokenId: freezed == tokenId
//           ? _value.tokenId
//           : tokenId // ignore: cast_nullable_to_non_nullable
//               as String?,
//       nftContract: freezed == nftContract
//           ? _value.nftContract
//           : nftContract // ignore: cast_nullable_to_non_nullable
//               as String?,
//       nitialSupply: freezed == nitialSupply
//           ? _value.nitialSupply
//           : nitialSupply // ignore: cast_nullable_to_non_nullable
//               as int?,
//       image: freezed == image
//           ? _value.image
//           : image // ignore: cast_nullable_to_non_nullable
//               as String?,
//       tokenURI: freezed == tokenURI
//           ? _value.tokenURI
//           : tokenURI // ignore: cast_nullable_to_non_nullable
//               as String?,
//       name: freezed == name
//           ? _value.name
//           : name // ignore: cast_nullable_to_non_nullable
//               as String?,
//       typeoff: freezed == typeoff
//           ? _value.typeoff
//           : typeoff // ignore: cast_nullable_to_non_nullable
//               as String?,
//       uri: freezed == uri
//           ? _value.uri
//           : uri // ignore: cast_nullable_to_non_nullable
//               as String?,
//       createdAt: freezed == createdAt
//           ? _value.createdAt
//           : createdAt // ignore: cast_nullable_to_non_nullable
//               as double?,
//       updatedAt: freezed == updatedAt
//           ? _value.updatedAt
//           : updatedAt // ignore: cast_nullable_to_non_nullable
//               as double?,
//     ));
//   }
// }

// /// @nodoc

// @JsonSerializable(explicitToJson: true)
// class _$_Asset with DiagnosticableTreeMixin implements _Asset {
//   const _$_Asset(
//       {required this.id,
//       this.tokenId,
//       this.nftContract,
//       this.nitialSupply,
//       this.image,
//       this.tokenURI,
//       this.name,
//       this.typeoff,
//       this.uri,
//       this.createdAt,
//       this.updatedAt});

//   factory _$_Asset.fromJson(Map<String, dynamic> json) =>
//       _$$_AssetFromJson(json);

//   @override
//   final int id;
// //  required Account accountID,
// //  required Addresss addressID,
//   @override
//   final String? tokenId;
//   @override
//   final String? nftContract;
//   @override
//   final int? nitialSupply;
//   @override
//   final String? image;
//   @override
//   final String? tokenURI;
//   @override
//   final String? name;
//   @override
//   final String? typeoff;
//   @override
//   final String? uri;
//   @override
//   final double? createdAt;
//   @override
//   final double? updatedAt;

//   @override
//   String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
//     return 'Asset(id: $id, tokenId: $tokenId, nftContract: $nftContract, nitialSupply: $nitialSupply, image: $image, tokenURI: $tokenURI, name: $name, typeoff: $typeoff, uri: $uri, createdAt: $createdAt, updatedAt: $updatedAt)';
//   }

//   @override
//   void debugFillProperties(DiagnosticPropertiesBuilder properties) {
//     super.debugFillProperties(properties);
//     properties
//       ..add(DiagnosticsProperty('type', 'Asset'))
//       ..add(DiagnosticsProperty('id', id))
//       ..add(DiagnosticsProperty('tokenId', tokenId))
//       ..add(DiagnosticsProperty('nftContract', nftContract))
//       ..add(DiagnosticsProperty('nitialSupply', nitialSupply))
//       ..add(DiagnosticsProperty('image', image))
//       ..add(DiagnosticsProperty('tokenURI', tokenURI))
//       ..add(DiagnosticsProperty('name', name))
//       ..add(DiagnosticsProperty('typeoff', typeoff))
//       ..add(DiagnosticsProperty('uri', uri))
//       ..add(DiagnosticsProperty('createdAt', createdAt))
//       ..add(DiagnosticsProperty('updatedAt', updatedAt));
//   }

//   @override
//   bool operator ==(dynamic other) {
//     return identical(this, other) ||
//         (other.runtimeType == runtimeType &&
//             other is _$_Asset &&
//             (identical(other.id, id) || other.id == id) &&
//             (identical(other.tokenId, tokenId) || other.tokenId == tokenId) &&
//             (identical(other.nftContract, nftContract) ||
//                 other.nftContract == nftContract) &&
//             (identical(other.nitialSupply, nitialSupply) ||
//                 other.nitialSupply == nitialSupply) &&
//             (identical(other.image, image) || other.image == image) &&
//             (identical(other.tokenURI, tokenURI) ||
//                 other.tokenURI == tokenURI) &&
//             (identical(other.name, name) || other.name == name) &&
//             (identical(other.typeoff, typeoff) || other.typeoff == typeoff) &&
//             (identical(other.uri, uri) || other.uri == uri) &&
//             (identical(other.createdAt, createdAt) ||
//                 other.createdAt == createdAt) &&
//             (identical(other.updatedAt, updatedAt) ||
//                 other.updatedAt == updatedAt));
//   }

//   @JsonKey(ignore: true)
//   @override
//   int get hashCode => Object.hash(runtimeType, id, tokenId, nftContract,
//       nitialSupply, image, tokenURI, name, typeoff, uri, createdAt, updatedAt);

//   @JsonKey(ignore: true)
//   @override
//   @pragma('vm:prefer-inline')
//   _$$_AssetCopyWith<_$_Asset> get copyWith =>
//       __$$_AssetCopyWithImpl<_$_Asset>(this, _$identity);

//   @override
//   Map<String, dynamic> toJson() {
//     return _$$_AssetToJson(
//       this,
//     );
//   }
// }

// abstract class _Asset implements Asset {
//   const factory _Asset(
//       {required final int id,
//       final String? tokenId,
//       final String? nftContract,
//       final int? nitialSupply,
//       final String? image,
//       final String? tokenURI,
//       final String? name,
//       final String? typeoff,
//       final String? uri,
//       final double? createdAt,
//       final double? updatedAt}) = _$_Asset;

//   factory _Asset.fromJson(Map<String, dynamic> json) = _$_Asset.fromJson;

//   @override
//   int get id;
//   @override //  required Account accountID,
// //  required Addresss addressID,
//   String? get tokenId;
//   @override
//   String? get nftContract;
//   @override
//   int? get nitialSupply;
//   @override
//   String? get image;
//   @override
//   String? get tokenURI;
//   @override
//   String? get name;
//   @override
//   String? get typeoff;
//   @override
//   String? get uri;
//   @override
//   double? get createdAt;
//   @override
//   double? get updatedAt;
//   @override
//   @JsonKey(ignore: true)
//   _$$_AssetCopyWith<_$_Asset> get copyWith =>
//       throw _privateConstructorUsedError;
// }
